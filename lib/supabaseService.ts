import { Recipe, supabase } from './supabase';

export class SupabaseService {
  /**
   * Fetch all rows from the `recipes` table (legacy example table).
   * This is not used by the new Home feed which reads from `test_recipes`.
   */
  static async getRecipes(): Promise<Recipe[]> {
    try {
      const { data, error } = await supabase
        .from('recipes')
        .select('*')
        .order('created_at', { ascending: false });
      if (error) {
        console.error('Error fetching recipes:', error);
        throw error;
      }

      return data || [];
    } catch (error) {
      console.error('Error in getRecipes:', error);
      throw error;
    }
  }

  /**
   * Fetch rows from `test_recipes` selecting the exact columns that exist.
   * Note: We do not order by `created_at` since that column isn't in the table.
   * Pass a limit to restrict results; omit to fetch all rows.
   */
  static async getTestRecipes(limit?: number): Promise<Array<{
    id?: string;
    recipe_name: string;
    ingredients: string;
    instructions: string;
    photo_url: string;
  }>> {
    try {
      let query = supabase
        .from('test_recipes')
        .select('recipe_name, ingredients, instructions, photo_url');

      if (typeof limit === 'number') {
        query = query.limit(limit);
      }

      const { data, error } = await query;

      if (error) {
        console.error('Error fetching test_recipes:', error);
        throw error;
      }
      return (data || []) as any;
    } catch (error) {
      console.error('Error in getTestRecipes:', error);
      throw error;
    }
  }

  /**
   * Fetch a single row from `recipes` by id (legacy example table).
   */
  static async getRecipe(id: string): Promise<Recipe | null> {
    try {
      const { data, error } = await supabase
        .from('recipes')
        .select('*')
        .eq('id', id)
        .single();

      if (error) {
        console.error('Error fetching recipe:', error);
        throw error;
      }

      return data;
    } catch (error) {
      console.error('Error in getRecipe:', error);
      throw error;
    }
  }

  /**
   * Insert a new row into `recipes` (legacy example table).
   */
  static async createRecipe(recipe: Omit<Recipe, 'id' | 'created_at' | 'updated_at'>): Promise<Recipe> {
    try {
      const { data, error } = await supabase
        .from('recipes')
        .insert([recipe])
        .select()
        .single();

      if (error) {
        console.error('Error creating recipe:', error);
        throw error;
      }

      return data;
    } catch (error) {
      console.error('Error in createRecipe:', error);
      throw error;
    }
  }

  /**
   * Update an existing row in `recipes` by id (legacy example table).
   */
  static async updateRecipe(id: string, updates: Partial<Recipe>): Promise<Recipe> {
    try {
      const { data, error } = await supabase
        .from('recipes')
        .update(updates)
        .eq('id', id)
        .select()
        .single();

      if (error) {
        console.error('Error updating recipe:', error);
        throw error;
      }

      return data;
    } catch (error) {
      console.error('Error in updateRecipe:', error);
      throw error;
    }
  }

  /**
   * Delete a row in `recipes` by id (legacy example table).
   */
  static async deleteRecipe(id: string): Promise<void> {
    try {
      const { error } = await supabase
        .from('recipes')
        .delete()
        .eq('id', id);

      if (error) {
        console.error('Error deleting recipe:', error);
        throw error;
      }
    } catch (error) {
      console.error('Error in deleteRecipe:', error);
      throw error;
    }
  }

  /**
   * Upload an image file/blob/bytes to Supabase Storage under `my-plate-bucket/recipes/`.
   * Accepts either a Web `Blob` or a `Uint8Array` (for native), with an optional contentType override.
   * Returns the public URL generated by Storage (requires public bucket or read policy).
   */
  static async uploadImage(file: Blob | Uint8Array, fileName: string, contentTypeOverride?: string): Promise<string> {
    try {
      console.log('üîÑ [SUPABASE] Starting upload process...');
      console.log('üìÅ [SUPABASE] File info:', {
        fileName,
        fileSize: (file as any)?.size ?? (file instanceof Uint8Array ? file.byteLength : undefined),
        fileType: (file as any)?.type || contentTypeOverride || 'unknown'
      });

      // Check authentication status
      const { data: { user }, error: authError } = await supabase.auth.getUser();
      console.log('üë§ [AUTH] User status:', user ? `Authenticated: ${user.email}` : 'Anonymous');
      if (authError) console.log('‚ö†Ô∏è [AUTH] Auth error:', authError);

      const fileExt = fileName.split('.').pop() || 'jpg';
      const filePath = `recipes/${Date.now()}_${Math.random().toString(36).substring(7)}.${fileExt}`;
      const contentType =
        contentTypeOverride ||
        (file as any)?.type ||
        (fileExt === 'png' ? 'image/png' :
         fileExt === 'jpg' || fileExt === 'jpeg' ? 'image/jpeg' :
         'application/octet-stream');

      console.log('üìã [UPLOAD] Upload details:', {
        filePath,
        contentType,
        bucket: 'my-plate-bucket'
      });

      const { data, error } = await supabase.storage
        .from('my-plate-bucket')
        .upload(filePath, file, { contentType, upsert: true });

      if (error) {
        console.error('‚ùå [UPLOAD] Upload failed:', {
          message: error.message,
          error: error
        });
        throw error;
      }

      console.log('‚úÖ [UPLOAD] Upload successful:', data);

      const { data: urlData } = supabase.storage
        .from('my-plate-bucket')
        .getPublicUrl(filePath);

      console.log('üîó [URL] Public URL generated:', urlData.publicUrl);
      return urlData.publicUrl;
    } catch (error) {
      console.error('‚ùå [ERROR] Error in uploadImage:', error);
      throw error;
    }
  }

  /**
   * Delete an image from Storage by its public URL.
   * This extracts the filename from the URL and removes `recipes/<filename>` from `my-plate-bucket`.
   */
  static async deleteImage(imageUrl: string): Promise<void> {
    try {
      // Extract file path from URL
      const urlParts = imageUrl.split('/');
      const filePath = urlParts[urlParts.length - 1];
      
      console.log('üóëÔ∏è [DELETE] Deleting image:', filePath);
      
      const { error } = await supabase.storage
        .from('my-plate-bucket')
        .remove([`recipes/${filePath}`]);

      if (error) {
        console.error('‚ùå [DELETE] Delete failed:', error);
        throw error;
      }

      console.log('‚úÖ [DELETE] Image deleted successfully');
    } catch (error) {
      console.error('‚ùå [ERROR] Error deleting image:', error);
      throw error;
    }
  }

  /**
   * Insert a new row into `test_recipes` with the shape used by the Create screen.
   * Fields: recipe_name, ingredients, instructions, photo_url
   * RLS: Requires an INSERT policy on `test_recipes` for your client role.
   */
  static async createTestRecipe(input: {
    recipe_name: string;
    ingredients: string;
    instructions: string;
    photo_url: string;
  }): Promise<{
    id?: string;
    recipe_name: string;
    ingredients: string;
    instructions: string;
    photo_url: string;
    created_at?: string;
    updated_at?: string;
  }> {
    try {
      const { data, error } = await supabase
        .from('test_recipes')
        .insert([input])
        .select()
        .single();

      if (error) {
        console.error('Error creating test_recipe:', error);
        throw error;
      }

      return data as any;
    } catch (error) {
      console.error('Error in createTestRecipe:', error);
      throw error;
    }
  }

  /**
   * List files in the `my-plate-bucket` under an optional prefix.
   */
  static async listBucketFiles(prefix = '', limit = 20): Promise<string[]> {
    const { data, error } = await supabase.storage
      .from('my-plate-bucket')
      .list(prefix, { limit, sortBy: { column: 'name', order: 'asc' } });

    if (error) {
      console.error('Error listing bucket files:', error);
      throw error;
    }
    return (data || []).map((f) => f.name);
  }
}